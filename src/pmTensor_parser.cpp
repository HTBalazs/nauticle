/*
    Copyright 2016-2017 Balazs Toth
    This file is part of Nauticle.

    Nauticle is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Nauticle is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Nauticle.  If not, see <http://www.gnu.org/licenses/>.

    For more information please visit: https://bitbucket.org/nauticleproject/
*/

#include "pmTensor_parser.h"
#include "commonutils/Common.h"

/////////////////////////////////////////////////////////////////////////////////////////
/// This member function verifies the data format and returns false is something's wrong.
/////////////////////////////////////////////////////////////////////////////////////////
bool pmTensor_parser::verify_infix(std::string const& data) const {
	for(auto const& it:data) {
		if(!is_bracket(it) && !is_letter(it) && !is_logical(it) && !is_digit(it) && !is_operator(it) && it!=',' && it!=';' && it!='|' && it!='.') {
			return false;
		}
	}
	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// This member function builds an std::vector<std::string> using the content of the given
/// tensor in std::string format. All characters are used except for white spaces.
/////////////////////////////////////////////////////////////////////////////////////////
std::vector<std::string> pmTensor_parser::build_table(std::string const& data) {
	numrow = Common::find_word(data,"|").size()+1;
	numcol = (Common::find_word(data,";").size()+numrow)/numrow;

	std::string::const_iterator it = data.cbegin();
	std::vector<std::string> words;
	while(it!=data.cend()) {
		if(*it=='|' || *it==';') {
			words.push_back(std::string{it[0]}); 
			it++;
		} else {
			std::string word;
			while(*it!='|' && *it!=';' && it!=data.cend()) {
				word+=*it;
				it++;
			}
			words.push_back(word);
		}
	}
	return words;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// This member function builds the final pmTensor object based on the table generated by
/// the pmTensor_parser::build_table(std::string const& data) member function.
/////////////////////////////////////////////////////////////////////////////////////////
pmTensor pmTensor_parser::build_tensor(std::vector<std::string> const& table, std::shared_ptr<pmWorkspace> const& workspace, int const& i/*=0*/) const {
	pmTensor tensor{numrow, numcol, 0};
	int count=0;
	for(auto const& it:table) {
		if(it!="|" && it!=";") {
			std::shared_ptr<pmExpression_parser> parser = std::make_shared<pmExpression_parser>();
			std::shared_ptr<pmExpression> expression{parser->analyse_expression<pmExpression>(it, workspace)};
			pmTensor tmp = expression->evaluate(i);
			if(tmp.numel()>1 && (numrow>1 || numcol>1)) {
				pLogger::error_msg("Component has more that one element.\n");
				return pmTensor{};
			} else if(numrow==1 && numcol==1) {
				tensor = tmp;
				break;
			}
			tensor[count] = tmp[0];
			if(!tmp.is_scalar()) {
				tensor.set_scalar(false);
			}
			count++;
		}
	}
	return tensor;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// This member function makes the analysis of the std::string formatted tensor strored in
/// raw_data and returns the final pmTensor object by value.
/////////////////////////////////////////////////////////////////////////////////////////
pmTensor pmTensor_parser::string_to_tensor(std::string const& raw_data, std::shared_ptr<pmWorkspace> const& workspace /*=std::make_shared<pmWorkspace>()*/) {
	std::string data = raw_data;
	remove_spaces(data);
	if(!verify_infix(data)) {
		pLogger::error_msgf("Invalid tensor: \"%s\"\n", data.c_str());
		return pmTensor{};
	}
	std::vector<std::string> table = build_table(data);
	return build_tensor(table, workspace);
}

/////////////////////////////////////////////////////////////////////////////////////////
/// This member function makes the analysis of the std::string formatted tensor strored in
/// raw_data and returns the final pmTensor object by value.
/////////////////////////////////////////////////////////////////////////////////////////
std::vector<pmTensor> pmTensor_parser::string_to_tensor_field(std::string const& raw_data, std::shared_ptr<pmWorkspace> const& workspace) {
	std::string data = raw_data;
	remove_spaces(data);
	if(!verify_infix(data)) {
		pLogger::error_msgf("Invalid tensor: \"%s\"\n", data.c_str());
	}
	std::vector<pmTensor> values;
	std::vector<std::string> table = build_table(data);
	for(int i=0; i<workspace->get_number_of_nodes(); i++) {
		values.push_back(build_tensor(table, workspace, i));
	}
	return values;
}














